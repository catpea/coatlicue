<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coatlicue's Children</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      overflow: hidden;
      font-family: 'Courier New', monospace;
    }

    svg {
      width: 100vw;
      height: 100vh;
      display: block;
    }

    .scene {
      opacity: 0;
    }

    .star {
      fill: none;
      stroke: #fff;
      stroke-width: 0.5;
    }

    .star-fill {
      fill: #fff;
    }

    .orbit-path {
      fill: none;
      stroke: rgba(255, 255, 255, 0.15);
      stroke-width: 0.5;
    }

    .spiral-arm {
      fill: none;
      stroke: rgba(255, 255, 255, 0.1);
      stroke-width: 1;
    }

    .galactic-bar {
      fill: none;
      stroke: rgba(255, 255, 255, 0.2);
      stroke-width: 2;
      transform-origin: 500px 300px;
    }

    .label {
      fill: rgba(255, 255, 255, 0.6);
      font-family: 'Courier New', monospace;
      font-size: 10px;
    }

    .title-text {
      fill: rgba(255, 255, 255, 0.8);
      font-family: 'Courier New', monospace;
      font-size: 12px;
      letter-spacing: 2px;
    }

    .poem-text {
      fill: rgba(255, 255, 255, 0.5);
      font-family: 'Courier New', monospace;
      font-size: 11px;
      font-style: italic;
    }

    .sibling-star {
      fill: none;
      stroke: #fff;
      stroke-width: 0.5;
    }

    .sun {
      fill: none;
      stroke: #fff;
      stroke-width: 1;
    }

    .convergence-line {
      fill: none;
      stroke: rgba(255, 255, 255, 0.3);
      stroke-width: 0.5;
      stroke-dasharray: 2, 4;
    }

    .wave-ring {
      fill: none;
      stroke: rgba(255, 255, 255, 0.5);
      stroke-width: 0.5;
    }

    .supernova-ring {
      fill: none;
      stroke: #fff;
      stroke-width: 1;
    }

    .natal-cloud {
      fill: none;
      stroke: rgba(255, 255, 255, 0.2);
      stroke-width: 0.5;
    }

    .code-text {
      fill: rgba(255, 255, 255, 0.4);
      font-family: 'Courier New', monospace;
      font-size: 9px;
    }

    .trajectory {
      fill: none;
      stroke: rgba(255, 255, 255, 0.2);
      stroke-width: 0.5;
    }

    .coatlicue {
      fill: #fff;
    }

    .shockwave {
      fill: none;
      stroke: rgba(255, 255, 255, 0.8);
      stroke-width: 2;
    }

    .accretion-ring {
      fill: none;
      stroke: rgba(255, 255, 255, 0.3);
      stroke-width: 0.5;
    }
  </style>
</head>
<body>
  <svg id="canvas" viewBox="0 0 1000 600" preserveAspectRatio="xMidYMid slice">
    <defs>
      <radialGradient id="starGlow" cx="50%" cy="50%" r="50%">
        <stop offset="0%" stop-color="#fff" stop-opacity="0.8"/>
        <stop offset="100%" stop-color="#fff" stop-opacity="0"/>
      </radialGradient>
    </defs>

    <!-- Scene 0: Opening - The Billion Progenitors poem -->
    <g id="scene0" class="scene">
      <text x="500" y="200" text-anchor="middle" class="poem-text">The billion progenitor stars</text>
      <text x="500" y="220" text-anchor="middle" class="poem-text">that lived and died before the sun was born</text>
      <text x="500" y="250" text-anchor="middle" class="poem-text">wept in their remnants,</text>
      <text x="500" y="280" text-anchor="middle" class="poem-text">scattered their grief across the interstellar medium,</text>
      <text x="500" y="320" text-anchor="middle" class="poem-text">and waited.</text>
      <text x="500" y="380" text-anchor="middle" class="poem-text">Four and a half billion years,</text>
      <text x="500" y="410" text-anchor="middle" class="poem-text">they waited for her.</text>
    </g>

    <!-- Scene 1: The Billion Progenitors -->
    <g id="scene1" class="scene">
      <text x="500" y="50" text-anchor="middle" class="title-text">THE BILLION PROGENITORS</text>
    </g>

    <!-- Scene 2: Coatlicue - The Mother Star -->
    <g id="scene2" class="scene">
      <text x="500" y="50" text-anchor="middle" class="title-text">COATLICUE — 30 SOLAR MASSES</text>
      <text x="500" y="550" text-anchor="middle" class="label">the mother of the sun</text>
    </g>

    <!-- Scene 3: The Supernova -->
    <g id="scene3" class="scene">
      <text x="500" y="50" text-anchor="middle" class="title-text">4.568 BILLION YEARS AGO</text>
    </g>

    <!-- Scene 4: The Natal Cloud Collapse -->
    <g id="scene4" class="scene">
      <text x="500" y="50" text-anchor="middle" class="title-text">TRIGGERED COLLAPSE</text>
      <text x="500" y="550" text-anchor="middle" class="label">shockwave compresses molecular cloud</text>
    </g>

    <!-- Scene 5: Birth of Sisters -->
    <g id="scene5" class="scene">
      <text x="500" y="50" text-anchor="middle" class="title-text">HUNDREDS OF STARS ARE BORN</text>
    </g>

    <!-- Scene 6: Galactic Dynamics -->
    <g id="scene6" class="scene">
      <text x="500" y="50" text-anchor="middle" class="title-text">GALACTIC POTENTIAL</text>
      <ellipse cx="500" cy="300" rx="60" ry="20" class="galactic-bar" id="galactic-bar"/>
    </g>

    <!-- Scene 7: Orbital Integration - Her Simulation -->
    <g id="scene7" class="scene">
      <text x="500" y="50" text-anchor="middle" class="title-text">integrateOrbitBackward()</text>
      <text x="80" y="100" class="code-text">function calculateGalacticPotential() {</text>
      <text x="80" y="115" class="code-text">  const bar = getBarPotential(t);</text>
      <text x="80" y="130" class="code-text">  const arms = getSpiralArmDensity(r, θ);</text>
      <text x="80" y="145" class="code-text">  return integrate(star, dt);</text>
      <text x="80" y="160" class="code-text">}</text>
    </g>

    <!-- Scene 8: Finding Siblings - Convergence -->
    <g id="scene8" class="scene">
      <text x="500" y="50" text-anchor="middle" class="title-text">COATLICUE'S CHILDREN</text>
      <circle cx="500" cy="300" r="8" class="sun" id="the-sun"/>
      <text x="500" y="330" text-anchor="middle" class="label">SOL</text>
    </g>

    <!-- Scene 9: HD 162826 Discovery -->
    <g id="scene9" class="scene">
      <text x="500" y="50" text-anchor="middle" class="title-text">HD 162826 — 110 LIGHT-YEARS — HERCULES</text>
      <text x="500" y="550" text-anchor="middle" class="label">first confirmed solar sibling · 2014</text>
    </g>

    <!-- Scene 10: Presolar Grains -->
    <g id="scene10" class="scene">
      <text x="500" y="50" text-anchor="middle" class="title-text">PRESOLAR GRAINS</text>
      <text x="500" y="530" text-anchor="middle" class="label">silicon carbide · nanodiamond · graphite</text>
      <text x="500" y="550" text-anchor="middle" class="poem-text">messages from dead stars, falling through her hair</text>
    </g>

    <!-- Scene 11: Closing -->
    <g id="scene11" class="scene">
      <text x="500" y="270" text-anchor="middle" class="title-text">36 DAYS LEFT</text>
      <text x="500" y="310" text-anchor="middle" class="poem-text">she kept working</text>
      <text x="500" y="360" text-anchor="middle" class="label">we are not alone in the galaxy</text>
      <text x="500" y="380" text-anchor="middle" class="label">we have family</text>
    </g>
  </svg>

  <script type="module">
    import { animate, stagger, utils } from 'https://esm.sh/animejs@4.2.2';

    // Utility functions
    function createSVGElement(type, attrs) {
      const el = document.createElementNS('http://www.w3.org/2000/svg', type);
      for (const [key, value] of Object.entries(attrs)) {
        el.setAttribute(key, value);
      }
      return el;
    }

    function polarToCartesian(cx, cy, r, angle) {
      return {
        x: cx + r * Math.cos(angle),
        y: cy + r * Math.sin(angle)
      };
    }

    function wait(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Scene Initializers
    function initScene1() {
      const scene = document.getElementById('scene1');
      const stars = [];
      for (let i = 0; i < 200; i++) {
        const star = createSVGElement('circle', {
          cx: Math.random() * 1000,
          cy: 80 + Math.random() * 480,
          r: 0.5 + Math.random() * 1.5,
          class: 'star-fill',
          opacity: 0
        });
        scene.appendChild(star);
        stars.push(star);
      }
      return stars;
    }

    function initScene2() {
      const scene = document.getElementById('scene2');
      const elements = { core: null, rings: [], particles: [] };

      // Coatlicue - massive star core
      elements.core = createSVGElement('circle', {
        cx: 500, cy: 300, r: 0,
        class: 'coatlicue',
        opacity: 0
      });
      scene.appendChild(elements.core);

      // Surrounding stellar wind rings
      for (let i = 0; i < 5; i++) {
        const ring = createSVGElement('circle', {
          cx: 500, cy: 300, r: 30 + i * 15,
          class: 'accretion-ring',
          opacity: 0
        });
        scene.appendChild(ring);
        elements.rings.push(ring);
      }

      // Wind particles
      for (let i = 0; i < 40; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = 40 + Math.random() * 80;
        const pos = polarToCartesian(500, 300, dist, angle);
        const particle = createSVGElement('circle', {
          cx: pos.x, cy: pos.y, r: 1,
          class: 'star-fill',
          opacity: 0
        });
        particle.baseAngle = angle;
        particle.baseDist = dist;
        scene.appendChild(particle);
        elements.particles.push(particle);
      }

      return elements;
    }

    function initScene3() {
      const scene = document.getElementById('scene3');
      const elements = { core: null, shockwaves: [], debris: [] };

      // Collapsing core
      elements.core = createSVGElement('circle', {
        cx: 500, cy: 300, r: 20,
        class: 'star-fill',
        opacity: 0
      });
      scene.appendChild(elements.core);

      // Shockwave rings
      for (let i = 0; i < 8; i++) {
        const ring = createSVGElement('circle', {
          cx: 500, cy: 300, r: 5,
          class: 'shockwave',
          opacity: 0
        });
        scene.appendChild(ring);
        elements.shockwaves.push(ring);
      }

      // Debris/ejecta
      for (let i = 0; i < 60; i++) {
        const angle = Math.random() * Math.PI * 2;
        const debris = createSVGElement('circle', {
          cx: 500, cy: 300, r: 0.5 + Math.random() * 1.5,
          class: 'star-fill',
          opacity: 0
        });
        debris.angle = angle;
        debris.speed = 0.5 + Math.random() * 1.5;
        scene.appendChild(debris);
        elements.debris.push(debris);
      }

      return elements;
    }

    function initScene4() {
      const scene = document.getElementById('scene4');
      const elements = { cloudParticles: [], shockwave: null };

      // Molecular cloud particles - scattered
      for (let i = 0; i < 150; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = 50 + Math.random() * 200;
        const pos = polarToCartesian(500, 300, dist, angle);
        const particle = createSVGElement('circle', {
          cx: pos.x, cy: pos.y, r: 1 + Math.random() * 2,
          class: 'star-fill',
          opacity: 0
        });
        particle.startX = pos.x;
        particle.startY = pos.y;
        particle.angle = angle;
        particle.dist = dist;
        scene.appendChild(particle);
        elements.cloudParticles.push(particle);
      }

      // Incoming shockwave
      elements.shockwave = createSVGElement('circle', {
        cx: 100, cy: 300, r: 50,
        class: 'shockwave',
        opacity: 0
      });
      scene.appendChild(elements.shockwave);

      return elements;
    }

    function initScene5() {
      const scene = document.getElementById('scene5');
      const stars = [];

      // Central dense region where stars form
      for (let i = 0; i < 80; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * Math.random() * 150; // Concentrated toward center
        const pos = polarToCartesian(500, 300, dist, angle);
        const star = createSVGElement('circle', {
          cx: 500, cy: 300, r: 0,
          class: 'star-fill',
          opacity: 0
        });
        star.finalX = pos.x;
        star.finalY = pos.y;
        star.finalR = 1 + Math.random() * 3;
        star.delay = dist * 10;
        scene.appendChild(star);
        stars.push(star);
      }

      // Mark the Sun
      const sun = createSVGElement('circle', {
        cx: 500, cy: 300, r: 0,
        class: 'sun',
        opacity: 0
      });
      sun.finalX = 500 + (Math.random() - 0.5) * 60;
      sun.finalY = 300 + (Math.random() - 0.5) * 60;
      sun.finalR = 4;
      sun.delay = 500;
      scene.appendChild(sun);
      stars.push(sun);

      return stars;
    }

    function initScene6() {
      const scene = document.getElementById('scene6');
      const elements = { spirals: [], stars: [] };

      for (let arm = 0; arm < 4; arm++) {
        const baseAngle = arm * Math.PI / 2;
        let pathD = '';
        for (let i = 0; i < 100; i++) {
          const r = 80 + i * 2;
          const angle = baseAngle + i * 0.08;
          const point = polarToCartesian(500, 300, r, angle);
          pathD += (i === 0 ? 'M' : 'L') + `${point.x},${point.y}`;
        }
        const spiral = createSVGElement('path', { d: pathD, class: 'spiral-arm' });
        scene.appendChild(spiral);
        elements.spirals.push(spiral);
      }

      for (let i = 0; i < 150; i++) {
        const arm = Math.floor(Math.random() * 4);
        const dist = 80 + Math.random() * 180;
        const angle = arm * Math.PI / 2 + (dist - 80) * 0.04 + (Math.random() - 0.5) * 0.3;
        const pos = polarToCartesian(500, 300, dist, angle);
        const star = createSVGElement('circle', { cx: pos.x, cy: pos.y, r: 1, class: 'star-fill', opacity: 0 });
        scene.appendChild(star);
        elements.stars.push(star);
      }
      return elements;
    }

    function initScene7() {
      const scene = document.getElementById('scene7');
      const elements = { orbits: [], stars: [] };

      for (let i = 1; i <= 8; i++) {
        const orbit = createSVGElement('circle', {
          cx: 500, cy: 300, r: i * 28,
          class: 'orbit-path',
          opacity: 0
        });
        scene.appendChild(orbit);
        elements.orbits.push(orbit);
      }

      for (let i = 0; i < 25; i++) {
        const orbitR = (1 + Math.floor(Math.random() * 8)) * 28;
        const angle = Math.random() * Math.PI * 2;
        const pos = polarToCartesian(500, 300, orbitR, angle);
        const star = createSVGElement('circle', {
          cx: pos.x, cy: pos.y, r: 2,
          class: 'star',
          opacity: 0
        });
        star.orbitRadius = orbitR;
        star.orbitAngle = angle;
        scene.appendChild(star);
        elements.stars.push(star);

        // Add trajectory trace
        const trajectory = createSVGElement('path', {
          d: `M${pos.x},${pos.y}`,
          class: 'trajectory',
          opacity: 0
        });
        trajectory.pathData = [`M${pos.x},${pos.y}`];
        scene.insertBefore(trajectory, star);
        star.trajectory = trajectory;
      }

      return elements;
    }

    function initScene8() {
      const scene = document.getElementById('scene8');
      const siblings = [];
      const data = [
        { name: 'HD 162826', finalDist: 80, angle: 0.3 * Math.PI },
        { name: 'Candidate A', finalDist: 120, angle: 0.8 * Math.PI },
        { name: 'Candidate B', finalDist: 100, angle: 1.3 * Math.PI },
        { name: 'Candidate C', finalDist: 140, angle: 1.7 * Math.PI },
        { name: 'Candidate D', finalDist: 90, angle: 2.1 * Math.PI },
        { name: 'Candidate E', finalDist: 110, angle: 0.1 * Math.PI },
        { name: 'Candidate F', finalDist: 130, angle: 1.1 * Math.PI },
      ];

      data.forEach(d => {
        const startPos = polarToCartesian(500, 300, 220 + Math.random() * 120, Math.random() * Math.PI * 2);
        const endPos = polarToCartesian(500, 300, d.finalDist, d.angle);
        const line = createSVGElement('line', {
          x1: startPos.x, y1: startPos.y,
          x2: startPos.x, y2: startPos.y,
          class: 'convergence-line',
          opacity: 0
        });
        const star = createSVGElement('circle', {
          cx: startPos.x, cy: startPos.y, r: 3,
          class: 'sibling-star',
          opacity: 0
        });
        scene.appendChild(line);
        scene.appendChild(star);
        siblings.push({ star, line, startPos, endPos, data: d });
      });
      return siblings;
    }

    function initScene9() {
      const scene = document.getElementById('scene9');
      const elements = { center: null, rings: [], stars: [] };

      elements.center = createSVGElement('circle', {
        cx: 500, cy: 300, r: 3,
        class: 'star-fill',
        opacity: 0
      });
      scene.appendChild(elements.center);

      for (let i = 0; i < 6; i++) {
        const ring = createSVGElement('circle', {
          cx: 500, cy: 300, r: 10,
          class: 'wave-ring',
          opacity: 0
        });
        scene.appendChild(ring);
        elements.rings.push(ring);
      }

      for (let i = 0; i < 100; i++) {
        const dist = 30 + Math.random() * 250;
        const pos = polarToCartesian(500, 300, dist, Math.random() * Math.PI * 2);
        const star = createSVGElement('circle', {
          cx: pos.x, cy: pos.y, r: 0.5 + Math.random() * 1.5,
          class: 'star-fill',
          opacity: 0
        });
        scene.appendChild(star);
        elements.stars.push({ el: star, dist });
      }
      return elements;
    }

    function initScene10() {
      const scene = document.getElementById('scene10');
      const grains = [];

      for (let i = 0; i < 80; i++) {
        const x = 250 + Math.random() * 500;
        const y = 80 + Math.random() * 420;
        const type = Math.floor(Math.random() * 3);
        let grain;

        if (type === 0) {
          // Diamond
          const s = 2 + Math.random() * 5;
          grain = createSVGElement('rect', {
            x: x - s/2, y: y - s/2,
            width: s, height: s,
            transform: `rotate(45 ${x} ${y})`,
            class: 'star',
            opacity: 0
          });
        } else if (type === 1) {
          // Silicon carbide hexagon
          const r = 2 + Math.random() * 4;
          const pts = [];
          for (let j = 0; j < 6; j++) {
            pts.push(`${x + r * Math.cos(j * Math.PI / 3)},${y + r * Math.sin(j * Math.PI / 3)}`);
          }
          grain = createSVGElement('polygon', {
            points: pts.join(' '),
            class: 'star',
            opacity: 0
          });
        } else {
          // Graphite sphere
          grain = createSVGElement('circle', {
            cx: x, cy: y, r: 1.5 + Math.random() * 2.5,
            class: 'star',
            opacity: 0
          });
        }

        grain.startY = y - 50 - Math.random() * 100;
        grain.endY = y + 50 + Math.random() * 100;
        scene.appendChild(grain);
        grains.push(grain);
      }
      return grains;
    }

    // Initialize all scenes
    const scene1Stars = initScene1();
    const scene2Elements = initScene2();
    const scene3Elements = initScene3();
    const scene4Elements = initScene4();
    const scene5Stars = initScene5();
    const scene6Elements = initScene6();
    const scene7Elements = initScene7();
    const scene8Siblings = initScene8();
    const scene9Elements = initScene9();
    const scene10Grains = initScene10();

    // Animation functions
    async function animateScene0() {
      const texts = document.querySelectorAll('#scene0 text');
      await animate('#scene0', { opacity: { from: 0, to: 1 }, duration: 10, ease: 'inOutQuad' });
      await animate(texts, {
        opacity: { from: 0, to: 1 },
        translateY: { from: '10px', to: '0px' },
        delay: stagger(400),
        duration: 1000,
        ease: 'outQuad'
      });
      await wait(11000);
      await animate('#scene0', { opacity: 0, duration: 1500 });
    }

    async function animateScene1() {
      await animate('#scene1', { opacity: { from: 0, to: 1 }, duration: 1000 });
      await animate(scene1Stars, {
        opacity: () => 0.3 + Math.random() * 0.7,
        delay: stagger(15, { from: 'random' }),
        duration: 600
      });
      await wait(2500);
      await animate(scene1Stars, {
        opacity: 0,
        delay: stagger(10, { from: 'random' }),
        duration: 500
      });
      await animate('#scene1', { opacity: 0, duration: 500 });
    }

    async function animateScene2() {
      const { core, rings, particles } = scene2Elements;

      await animate('#scene2', { opacity: { from: 0, to: 1 }, duration: 1000 });

      // Core appears and pulses
      await animate(core, {
        opacity: { from: 0, to: 1 },
        r: { from: 0, to: 25 },
        duration: 1500,
        ease: 'outQuad'
      });

      // Rings expand outward
      animate(rings, {
        opacity: { from: 0, to: 0.5 },
        r: (el, i) => ({ from: 30, to: 50 + i * 20 }),
        delay: stagger(200),
        duration: 2000
      });

      // Particles drift outward (stellar wind)
      animate(particles, {
        opacity: { from: 0, to: 0.6 },
        duration: 500
      });

      // Animate particles outward
      const particleAnim = { progress: 0 };
      await animate(particleAnim, {
        progress: { from: 0, to: 1 },
        duration: 3000,
        ease: 'linear',
        update: () => {
          particles.forEach(p => {
            const newDist = p.baseDist + particleAnim.progress * 60;
            const pos = polarToCartesian(500, 300, newDist, p.baseAngle);
            p.setAttribute('cx', pos.x);
            p.setAttribute('cy', pos.y);
          });
        }
      });

      await wait(500);
      await animate('#scene2', { opacity: 0, duration: 800 });
    }

    async function animateScene3() {
      const { core, shockwaves, debris } = scene3Elements;

      await animate('#scene3', { opacity: { from: 0, to: 1 }, duration: 800 });

      // Core appears
      await animate(core, {
        opacity: { from: 0, to: 1 },
        r: { from: 0, to: 20 },
        duration: 500
      });

      await wait(500);

      // Core collapse
      await animate(core, {
        r: { from: 20, to: 3 },
        duration: 300,
        ease: 'inQuad'
      });

      // EXPLOSION - core flash
      animate(core, {
        r: { from: 3, to: 80 },
        opacity: { from: 1, to: 0 },
        duration: 800,
        ease: 'outQuad'
      });

      // Shockwaves expand
      shockwaves.forEach((ring, i) => {
        animate(ring, {
          opacity: { from: 1, to: 0 },
          r: { from: 5, to: 350 },
          strokeWidth: { from: 3, to: 0.5 },
          duration: 2500,
          delay: i * 150,
          ease: 'outCubic'
        });
      });

      // Debris flies outward
      const debrisAnim = { progress: 0 };
      animate(debris, { opacity: { from: 0, to: 1 }, duration: 200 });
      await animate(debrisAnim, {
        progress: { from: 0, to: 1 },
        duration: 2500,
        ease: 'outQuad',
        update: () => {
          debris.forEach(d => {
            const dist = debrisAnim.progress * 350 * d.speed;
            const x = 500 + Math.cos(d.angle) * dist;
            const y = 300 + Math.sin(d.angle) * dist;
            d.setAttribute('cx', x);
            d.setAttribute('cy', y);
            d.setAttribute('opacity', 1 - debrisAnim.progress * 0.8);
          });
        }
      });

      await wait(500);
      await animate('#scene3', { opacity: 0, duration: 800 });
    }

    async function animateScene4() {
      const { cloudParticles, shockwave } = scene4Elements;

      // Reset positions
      cloudParticles.forEach(p => {
        p.setAttribute('cx', p.startX);
        p.setAttribute('cy', p.startY);
      });
      shockwave.setAttribute('cx', 100);

      await animate('#scene4', { opacity: { from: 0, to: 1 }, duration: 800 });

      // Cloud appears
      await animate(cloudParticles, {
        opacity: { from: 0, to: 0.4 },
        delay: stagger(10, { from: 'random' }),
        duration: 500
      });

      // Shockwave arrives from left
      animate(shockwave, {
        opacity: { from: 0, to: 0.8 },
        duration: 300
      });

      await animate(shockwave, {
        cx: { from: 100, to: 900 },
        opacity: { from: 0.8, to: 0 },
        duration: 2000,
        ease: 'linear'
      });

      // Cloud compresses as shockwave passes
      const compressAnim = { progress: 0 };
      await animate(compressAnim, {
        progress: { from: 0, to: 1 },
        duration: 2000,
        ease: 'inOutQuad',
        update: () => {
          cloudParticles.forEach(p => {
            const compressionFactor = 1 - compressAnim.progress * 0.7;
            const newDist = p.dist * compressionFactor;
            const pos = polarToCartesian(500, 300, newDist, p.angle);
            p.setAttribute('cx', pos.x);
            p.setAttribute('cy', pos.y);
            p.setAttribute('opacity', 0.4 + compressAnim.progress * 0.4);
          });
        }
      });

      await wait(1000);
      await animate('#scene4', { opacity: 0, duration: 800 });
    }

    async function animateScene5() {
      // Reset
      scene5Stars.forEach(s => {
        s.setAttribute('cx', 500);
        s.setAttribute('cy', 300);
        s.setAttribute('r', 0);
      });

      await animate('#scene5', { opacity: { from: 0, to: 1 }, duration: 800 });

      // Stars ignite one by one, spreading outward
      await animate(scene5Stars, {
        cx: (el) => el.finalX,
        cy: (el) => el.finalY,
        r: (el) => el.finalR,
        opacity: { from: 0, to: 1 },
        delay: (el) => el.delay,
        duration: 800,
        ease: 'outQuad'
      });

      // Gentle pulse
      await animate(scene5Stars, {
        r: (el) => el.finalR * 1.2,
        duration: 1000,
        ease: 'inOutSine',
        direction: 'alternate',
        loop: 2
      });

      await wait(1000);
      await animate('#scene5', { opacity: 0, duration: 800 });
    }

    async function animateScene6() {
      const { spirals, stars } = scene6Elements;
      document.getElementById('galactic-bar').style.transform = 'rotate(0deg)';

      await animate('#scene6', { opacity: { from: 0, to: 1 }, duration: 1000 });
      animate('#galactic-bar', { opacity: { from: 0, to: 1 }, duration: 800 });
      animate(spirals, {
        strokeDashoffset: { from: utils.setDashoffset, to: 0 },
        duration: 3000,
        delay: stagger(200)
      });
      animate(stars, {
        opacity: { from: 0, to: 0.6 },
        delay: stagger(20, { from: 'center' }),
        duration: 400
      });
      await animate('#galactic-bar', { rotate: { from: 0, to: 45 }, duration: 5000, ease: 'linear' });
      await animate('#scene6', { opacity: 0, duration: 800 });
    }

    async function animateScene7() {
      const { orbits, stars } = scene7Elements;

      // Reset
      stars.forEach(star => {
        const pos = polarToCartesian(500, 300, star.orbitRadius, star.orbitAngle);
        star.setAttribute('cx', pos.x);
        star.setAttribute('cy', pos.y);
        star.trajectory.pathData = [`M${pos.x},${pos.y}`];
        star.trajectory.setAttribute('d', `M${pos.x},${pos.y}`);
      });

      await animate('#scene7', { opacity: { from: 0, to: 1 }, duration: 1000 });
      await animate(orbits, { opacity: { from: 0, to: 1 }, delay: stagger(80), duration: 400 });
      await animate(stars.map(s => s), { opacity: { from: 0, to: 1 }, delay: stagger(40), duration: 300 });
      animate(stars.map(s => s.trajectory), { opacity: { from: 0, to: 0.5 }, duration: 500 });

      // Orbital motion with trajectory trails
      const orbitAnim = { angle: 0 };
      await animate(orbitAnim, {
        angle: { from: 0, to: Math.PI * 1.5 },
        duration: 5000,
        ease: 'linear',
        update: () => {
          stars.forEach(star => {
            const currentAngle = star.orbitAngle + orbitAnim.angle * (0.5 + star.orbitRadius / 300);
            const pos = polarToCartesian(500, 300, star.orbitRadius, currentAngle);
            star.setAttribute('cx', pos.x);
            star.setAttribute('cy', pos.y);

            // Update trajectory (keep last 50 points)
            star.trajectory.pathData.push(`L${pos.x},${pos.y}`);
            if (star.trajectory.pathData.length > 50) {
              star.trajectory.pathData.shift();
              star.trajectory.pathData[0] = 'M' + star.trajectory.pathData[0].substring(1);
            }
            star.trajectory.setAttribute('d', star.trajectory.pathData.join(''));
          });
        }
      });

      await animate('#scene7', { opacity: 0, duration: 800 });
    }

    async function animateScene8() {
      // Reset siblings
      scene8Siblings.forEach(sib => {
        sib.star.setAttribute('cx', sib.startPos.x);
        sib.star.setAttribute('cy', sib.startPos.y);
        sib.line.setAttribute('x2', sib.startPos.x);
        sib.line.setAttribute('y2', sib.startPos.y);
      });

      await animate('#scene8', { opacity: { from: 0, to: 1 }, duration: 1000 });
      await animate('#the-sun', { opacity: { from: 0, to: 1 }, r: { from: 0, to: 8 }, duration: 1000 });

      animate(scene8Siblings.map(s => s.star), { opacity: { from: 0, to: 1 }, duration: 500 });
      await animate(scene8Siblings.map(s => s.line), { opacity: { from: 0, to: 0.5 }, duration: 500 });

      // Converge (time running backward)
      const convergeAnim = { progress: 0 };
      await animate(convergeAnim, {
        progress: { from: 0, to: 1 },
        duration: 3000,
        ease: 'inOutSine',
        update: () => {
          scene8Siblings.forEach(sib => {
            const x = sib.startPos.x + (sib.endPos.x - sib.startPos.x) * convergeAnim.progress;
            const y = sib.startPos.y + (sib.endPos.y - sib.startPos.y) * convergeAnim.progress;
            sib.star.setAttribute('cx', x);
            sib.star.setAttribute('cy', y);
            sib.line.setAttribute('x2', x);
            sib.line.setAttribute('y2', y);
          });
        }
      });

      // Pulse when converged
      await animate(scene8Siblings.map(s => s.star), {
        r: { from: 3, to: 5 },
        duration: 500,
        direction: 'alternate',
        loop: 2
      });

      await wait(1500);
      await animate('#scene8', { opacity: 0, duration: 800 });
    }

    async function animateScene9() {
      const { center, rings, stars } = scene9Elements;

      // Reset rings
      rings.forEach(r => {
        r.setAttribute('r', 10);
        r.setAttribute('opacity', 0);
      });

      await animate('#scene9', { opacity: { from: 0, to: 1 }, duration: 1000 });
      await animate(center, { opacity: { from: 0, to: 1 }, r: { from: 0, to: 6 }, duration: 500 });

      // Discovery wave
      rings.forEach((ring, i) => {
        animate(ring, {
          opacity: { from: 0.9, to: 0 },
          r: { from: 10, to: 320 },
          duration: 2500,
          delay: i * 350,
          ease: 'outCubic'
        });
      });

      // Stars light up as wave passes
      stars.sort((a, b) => a.dist - b.dist);
      await animate(stars.map(s => s.el), {
        opacity: { from: 0, to: 1 },
        r: { from: 0, to: (el, i) => 0.5 + Math.random() * 1.5 },
        delay: (el, i) => stars[i].dist * 6,
        duration: 200
      });

      await wait(2000);
      await animate('#scene9', { opacity: 0, duration: 800 });
    }

    async function animateScene10() {
      // Reset grains
      scene10Grains.forEach(g => {
        if (g.tagName === 'circle') {
          g.setAttribute('cy', g.startY);
        } else {
          g.style.transform = '';
        }
      });

      await animate('#scene10', { opacity: { from: 0, to: 1 }, duration: 1000 });

      // Grains appear and drift down
      await animate(scene10Grains, {
        opacity: () => 0.3 + Math.random() * 0.6,
        translateY: { from: '-30px', to: '0px' },
        rotate: () => Math.random() * 360,
        delay: stagger(30, { from: 'random' }),
        duration: 800
      });

      await wait(1500);

      // Continue falling
      await animate(scene10Grains, {
        translateY: { from: '0px', to: '80px' },
        opacity: { from: (el) => parseFloat(el.getAttribute('opacity')) || 0.5, to: 0 },
        delay: stagger(25, { from: 'random' }),
        duration: 3000,
        ease: 'inQuad'
      });

      await animate('#scene10', { opacity: 0, duration: 1000 });
    }

    async function animateScene11() {
      const texts = document.querySelectorAll('#scene11 text');
      await animate('#scene11', { opacity: { from: 0, to: 1 }, duration: 11 });
      await animate(texts, {
        opacity: { from: 0, to: 1 },
        delay: stagger(800),
        duration: 1000
      });
      await wait(4000);
      await animate('#scene11', { opacity: 0, duration: 2000 });
    }

    // Main loop
    async function runAnimation() {
      while (true) {
        await animateScene0();   // Opening poem
        await animateScene1();   // Billion progenitors
        await animateScene2();   // Coatlicue living
        await animateScene3();   // Supernova
        await animateScene4();   // Cloud collapse
        await animateScene5();   // Stars born
        await animateScene6();   // Galaxy dynamics
        await animateScene7();   // Her simulation
        await animateScene8();   // Finding siblings
        await animateScene9();   // HD 162826 discovery
        await animateScene10();  // Presolar grains
        await animateScene11();  // Closing
        await wait(2000);
      }
    }

    runAnimation();
  </script>
</body>
</html>
